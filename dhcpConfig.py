import os
import json
import ipaddress
from typing import Optional, Tuple
import logging
from dataclasses import dataclass, field
import sys

from logger import logger
import common
from clustersConfig import NodeConfig
import hashlib

from keaConfig import KeaConfig, KeaSubnet, KeaReservation
import host


DEFAULT_NETMASK = "255.255.255.0"
KEA_CONFIG_PATH = "/etc/kea/kea-dhcp4.conf"
KEA_CONFIG_BACKUP_PATH = "/etc/kea/kea-dhcp4.conf.cda-backup"
CDA_TAG = "Generated by CDA"


def get_subnet_ip(ipv4_address: str, subnet_mask: str) -> str:
    network = ipaddress.ip_network(f"{ipv4_address}/{subnet_mask}", strict=False)
    return str(network.network_address)


def get_subnet_range(ipv4_address: str, subnet_mask: str) -> Tuple[str, str]:
    network = ipaddress.ip_network(f"{ipv4_address}/{subnet_mask}", strict=False)
    range_start = network.network_address + 1
    range_end = network.broadcast_address - 1
    return str(range_start), str(range_end)


def get_router_ip(ipv4_address: str, subnet_mask: str) -> str:
    network = ipaddress.ip_network(f"{ipv4_address}/{subnet_mask}", strict=False)
    router_ip = network.network_address + 1
    return str(router_ip)


def dns_servers(lh: host.Host) -> list[str]:
    """Get the DNS servers for the given interface."""
    ret = []
    for e in lh.run("nmcli -g IP4.DNS device show").out.split():
        for d in e.strip().split("|"):
            if d:
                ret.append(d)
    return ret


def _convert_to_cidr(ipv4_address: str, subnet_mask: str) -> str:
    network = ipaddress.ip_network(f"{ipv4_address}/{subnet_mask}", strict=False)
    return str(network)


def create_kea_subnet_from_node(node: NodeConfig) -> KeaSubnet:
    """Create a Kea subnet configuration from a node configuration."""
    netmask = DEFAULT_NETMASK
    subnet_ip = get_subnet_ip(str(node.ip), netmask)
    range_start, range_end = get_subnet_range(str(node.ip), netmask)
    router_ip = get_router_ip(str(node.ip), netmask)
    dns = dns_servers(host.LocalHost())
    
    # Convert netmask to CIDR format
    subnet_cidr = _convert_to_cidr(subnet_ip, netmask)
    
    # Generate unique subnet ID based on node IP
    subnet_id = generate_unique_subnet_id(str(node.ip))
    
    # Create reservations for all MAC addresses
    reservations = []
    for mac in node.mac.split(";"):
        reservations.append(KeaReservation(
            hw_address=mac,
            ip_address=str(node.ip),
            hostname=node.name
        ))
    
    # Create option data with resolved NTP IPs
    ntp_ips = ", ".join(common.resolve_hostname_to_ips("clock.redhat.com"))
    option_data = [
        {"name": "routers", "data": router_ip},
        {"name": "domain-name", "data": "redhat.com anl.eng.bos2.dc.redhat.com"},
        {"name": "ntp-servers", "data": ntp_ips}
    ]
    
    if dns:
        option_data.append({
            "name": "domain-name-servers", 
            "data": ", ".join(dns)
        })
    
    return KeaSubnet(
        subnet=subnet_cidr,
        pools=[{"pool": f"{range_start} - {range_end}"}],
        option_data=option_data,
        reservations=reservations,
        id=subnet_id  # Use generated unique ID
    )


def configure_dhcpd(node: NodeConfig, interface: str) -> None:
    """Configure Kea DHCP for the given node."""
    logger.info("Configuring Kea DHCP entry")
    
    lh = host.LocalHost()
    
    # Validate interface exists
    logger.debug(f"Validating network interface: {interface}")
    result = lh.run(f"ip link show {interface}")
    if not result.success():
        logger.error(f"Network interface '{interface}' does not exist")
        logger.error(f"Available interfaces: {[entry.ifname for entry in common.ip_addrs(lh)]}")
        sys.exit(-1)
    
    # Validate interface has IP configuration
    try:
        entries = common.ip_addrs(lh, ifname=interface)
        if not entries:
            logger.warning(f"Interface '{interface}' exists but has no IP configuration")
        else:
            logger.debug(f"Interface '{interface}' has IP addresses: {[addr.local for entry in entries for addr in entry.addr_info if addr.family == 'inet']}")
    except Exception as e:
        logger.warning(f"Could not check IP configuration for interface '{interface}': {e}")
    
    # Create Kea configuration
    kea_config = KeaConfig(interface=interface)
    
    # Create subnet for this node
    subnet = create_kea_subnet_from_node(node)
    kea_config.add_subnet(subnet)
    
    # Write configuration to file
    logger.info(f"Writing Kea config to {KEA_CONFIG_PATH}")
    config_json = kea_config.to_json()
    
    # Backup existing config if it exists
    if lh.exists(KEA_CONFIG_PATH):
        logger.debug(f"Backing up existing Kea config to {KEA_CONFIG_BACKUP_PATH}")
        lh.run(f"cp {KEA_CONFIG_PATH} {KEA_CONFIG_BACKUP_PATH}")
    
    # Write new config
    lh.write(KEA_CONFIG_PATH, config_json)
    
    # Validate config syntax before restarting service
    logger.debug("Validating Kea configuration syntax")
    syntax_check = lh.run(f"kea-dhcp4 -t {KEA_CONFIG_PATH}")
    if not syntax_check.success():
        logger.error(f"Kea configuration syntax check failed: {syntax_check.err}")
        # Try to restore backup if syntax check failed
        if lh.exists(KEA_CONFIG_BACKUP_PATH):
            logger.info("Attempting to restore previous Kea config")
            lh.run(f"cp {KEA_CONFIG_BACKUP_PATH} {KEA_CONFIG_PATH}")
        sys.exit(-1)
    
    # Enable and restart Kea service (similar to dnsmasq management)
    logger.debug("Ensuring Kea DHCP service is unmasked and enabled")
    lh.run("systemctl unmask kea-dhcp4.service")
    lh.run("systemctl enable kea-dhcp4.service")
    
    logger.info("Restarting Kea DHCP service")
    ret = lh.run("systemctl restart kea-dhcp4")
    if ret.returncode != 0:
        logger.error(f"Failed to restart kea-dhcp4 with err: {ret.err}")
        # Try to restore backup if restart failed
        if lh.exists(KEA_CONFIG_BACKUP_PATH):
            logger.info("Attempting to restore previous Kea config")
            lh.run(f"cp {KEA_CONFIG_BACKUP_PATH} {KEA_CONFIG_PATH}")
            lh.run("systemctl restart kea-dhcp4")
        sys.exit(-1)
    
    # Verify service is actually running
    service_check = lh.run("systemctl is-active kea-dhcp4")
    if not service_check.success():
        logger.error("Kea DHCP service failed to start properly")
        logger.error("Check logs with: sudo journalctl -u kea-dhcp4 -n 20")
        sys.exit(-1)
    
    logger.info("Kea DHCP configuration completed successfully")


# Legacy compatibility - keeping old classes for any code that might still reference them
@dataclass
class DhcpdSubnetConfig:
    """Legacy class - use KeaSubnet instead."""
    subnet: str
    netmask: str
    range_start: str
    range_end: str
    broadcast_address: str
    routers: str
    dns_servers: list[str]
    domain_names: list[str] = field(default_factory=lambda: ["redhat.com", "anl.eng.bos2.dc.redhat.com"])
    ntp_servers: str = "clock.redhat.com"

    def to_string(self) -> str:
        logger.warning("DhcpdSubnetConfig.to_string() is deprecated - use Kea configuration instead")
        dns_servers_str = ", ".join(self.dns_servers)
        domain_names_str = " ".join(self.domain_names)
        return (
            f"# {CDA_TAG}\n"
            f"subnet {self.subnet} netmask {self.netmask} {{\n"
            f"    range {self.range_start} {self.range_end};\n"
            f"    option domain-name-servers {dns_servers_str};\n"
            f"    option routers {self.routers};\n"
            f"    option broadcast-address {self.broadcast_address};\n"
            f"    option domain-name \"{domain_names_str}\";\n"
            f"    option ntp-servers {self.ntp_servers};\n"
            f"}}\n"
        )


@dataclass
class DhcpdHostConfig:
    """Legacy class - use KeaReservation instead."""
    entry_name: str
    hardware_ethernet: str
    fixed_address: str
    dhcp_option: str

    def to_string(self) -> str:
        logger.warning("DhcpdHostConfig.to_string() is deprecated - use Kea configuration instead")
        return f"# {CDA_TAG}\n" f"host {self.entry_name} {{\n" f"    hardware ethernet {self.hardware_ethernet};\n" f"    fixed-address {self.fixed_address};\n" f"    option host-name {self.dhcp_option};\n" f"}}\n"


class DhcpConfigFile:
    """Legacy class - use KeaConfig instead."""
    
    def __init__(self):
        logger.warning("DhcpConfigFile is deprecated - use KeaConfig instead")
        self._subnet_configs: list[DhcpdSubnetConfig] = []
        self._host_configs: list[DhcpdHostConfig] = []

    def _get_subnets_str(self) -> list[str]:
        subnets = []
        for subnet in self._subnet_configs:
            subnets.append(_convert_to_cidr(subnet.subnet, subnet.netmask))
        return subnets

    def _add_subnet_from_dhcpdsubnetconfig(self, subnet: DhcpdSubnetConfig) -> None:
        self._subnet_configs.append(subnet)

    def _add_host_from_dhcpdhostconfig(self, host_config: DhcpdHostConfig) -> None:
        self._host_configs.append(host_config)

    def add_host(self, hostname: str, hardware_ethernet: str, fixed_address: str) -> None:
        logger.warning("DhcpConfigFile.add_host() is deprecated - use configure_dhcpd() directly")
        # Generate host / subnet configs for the current Node
        idx = len(self._host_configs)
        new_hostconfig = DhcpdHostConfig(entry_name=f"host{idx}", hardware_ethernet=hardware_ethernet, fixed_address=fixed_address, dhcp_option=hostname)
        subnetconfig = subnet_config_from_host_config(new_hostconfig)

        # Check if an existing subnet contains the host or subnet configuration, add a new entry if not
        if any(common.ip_in_subnet(new_hostconfig.fixed_address, subnet) for subnet in self._get_subnets_str()):
            logger.debug(f"Subnet config for {new_hostconfig.fixed_address} already exists")
        else:
            logger.debug(f"Subnet config for {new_hostconfig.fixed_address} does not exist, adding this")
            self._add_subnet_from_dhcpdsubnetconfig(subnetconfig)

        self._add_host_from_dhcpdhostconfig(new_hostconfig)

    def to_string(self) -> str:
        logger.warning("DhcpConfigFile.to_string() is deprecated - use Kea JSON configuration instead")
        config_str = ""
        for subnet in self._subnet_configs:
            config_str += subnet.to_string()
        for h in self._host_configs:
            config_str += h.to_string()
        return config_str

    def write_to_file(self, file_path: str = "/etc/dhcp/dhcpd.conf") -> None:
        logger.warning("DhcpConfigFile.write_to_file() is deprecated - use Kea configuration instead")
        with open(file_path, 'w') as file:
            file.write(self.to_string())


def subnet_config_from_host_config(hc: DhcpdHostConfig) -> DhcpdSubnetConfig:
    """Legacy function - use create_kea_subnet_from_node() instead."""
    logger.warning("subnet_config_from_host_config() is deprecated - use create_kea_subnet_from_node() instead")
    netmask = DEFAULT_NETMASK
    subnet_ip = get_subnet_ip(hc.fixed_address, netmask)
    range_start, range_end = get_subnet_range(hc.fixed_address, netmask)
    broadcast_address = str(ipaddress.ip_network(f"{hc.fixed_address}/{netmask}", strict=False).broadcast_address)
    routers = get_router_ip(hc.fixed_address, netmask)
    dns = dns_servers(host.LocalHost())
    return DhcpdSubnetConfig(subnet=subnet_ip, netmask=netmask, range_start=range_start, range_end=range_end, broadcast_address=broadcast_address, routers=routers, dns_servers=dns)


# Keep old constant for backward compatibility
DHCPD_CONFIG_PATH = "/etc/dhcp/dhcpd.conf"  # Legacy - use KEA_CONFIG_PATH instead
DHCPD_CONFIG_BACKUP_PATH = "/etc/dhcp/dhcpd.conf.cda-backup"  # Legacy - use KEA_CONFIG_BACKUP_PATH instead


def generate_unique_subnet_id(node_ip: str) -> int:
    """Generate a unique subnet ID based on the node IP address.
    
    This ensures different subnets get different IDs even if multiple
    nodes are configured in the same Kea instance.
    """
    # Use MD5 hash of IP address to generate consistent, unique ID
    hash_hex = hashlib.md5(str(node_ip).encode()).hexdigest()[:8]
    # Convert to int and constrain to valid range (1-65535)
    subnet_id = max(1, int(hash_hex, 16) % 65535)
    logger.debug(f"Generated subnet ID {subnet_id} for IP {node_ip}")
    return subnet_id

